import lingo/pegcode/driver;
import string;

export 
{
	Expr ::= Rational, Var, Neg, Add, Sub, Product, Div;
		Div : (e1 : Expr, e2 : Expr);
    	Product : (e1 : Expr, e2 : Expr);
		Sub : (e1 : Expr, e2 : Expr);
		Add : (e1 : Expr, e2 : Expr);
		Neg : (e : Expr);
		Var : (s : string);
		Rational : (numerator : int, denominator : int);
	algebraGrammar()  -> [PegOp];
	e2s(e : Expr) -> string;
	e2sVariables(e : Expr, values : [Pair<string,string>]) -> string;
	calc(e : Expr) -> Rational;
	calcVariables(e : Expr, values : [Pair<string,string>]) -> Rational;
}

algebraGrammarOp : ref Maybe<[PegOp]> = ref None();

algebraGrammar()
{
	onlyOnce(algebraGrammarOp, \ -> {
		compilePegGrammar("#include MTC/lab7/algebra_grammar.lingo");
	});
}

e2s(e)
{
	e2sVariables(e,[]);
}

e2sVariables(e,values)
{
	e2sParentheses(e,false,values);
}

e2sParentheses(e : Expr, underMulDivOrNeg : bool, values : [Pair<string,string>]) -> string
{
	switch (e : Expr)
	{
		Div(e1,e2) :
			e2sParentheses(e1,true,values) + " / " + e2sParentheses(e2,true,values);
		Product(e1,e2) :
			e2sParentheses(e1,true,values) + " * " + e2sParentheses(e2,true,values);
		Add(e1,e2) :
			if (underMulDivOrNeg)
				"(" + e2sParentheses(e1,false,values) + " + " + e2sParentheses(e2,false,values) + ")"
			else
				e2sParentheses(e1,false,values) + " + " + e2sParentheses(e2,false,values);
		Sub(e1,e2) :
			if (underMulDivOrNeg)
				"(" + e2sParentheses(e1,false,values) + " - " + e2sParentheses(e2,false,values) + ")"
			else
				e2sParentheses(e1,false,values) + " - " + e2sParentheses(e2,false,values);
		Neg(expr) :
			"-" + e2sParentheses(expr,true,values);
		Var(s) :
		{
			r = var2r(s,values);
			if (0 == r.denominator)
				s
			else
				r2s(r);
		}
		Rational(n,d) :
			if (0 != d && 0 == n % d)
				i2s(n/d)
			else
				i2s(n) + "/" + i2s(d);
	}
}

calc(e)
{
	calcVariables(e,[]);
}

calcVariables(e, values)
{
	switch(e : Expr)
	{
		Div(e1,e2) :
		{
			e1v = calcVariables(e1,values);
			e2v = calcVariables(e2,values);
			getRational(e1v.numerator * e2v.denominator, e2v.numerator * e1v.denominator);
		}
		Product(e1,e2) :
		{
			e1v = calcVariables(e1,values);
			e2v = calcVariables(e2,values);
			getRational(e1v.numerator * e2v.numerator, e1v.denominator * e2v.denominator);
		}
		Add(e1,e2) :
		{
			e1v = calcVariables(e1,values);
			e2v = calcVariables(e2,values);
			getRational(e1v.numerator * e2v.denominator + e2v.numerator * e1v.denominator,
				e1v.denominator * e2v.denominator);
		}
		Sub(e1,e2) :
		{
			e1v = calcVariables(e1,values);
			e2v = calcVariables(e2,values);
			getRational(e1v.numerator * e2v.denominator - e2v.numerator * e1v.denominator,
				e1v.denominator * e2v.denominator);
		}
		Neg(expr) :
		{
			ev = calcVariables(expr,values);
			getRational(-ev.numerator,ev.denominator);
		}
		Var(s) :
			var2r(s,values);
		Rational(n,d) :
			getRational(n,d)
	}
}

getRational(n : int, d : int)
{
	if (0 == d)
				Rational(0,0)
			else
				if (0 == n % d)
					Rational(n / d, 1)
				else
					if (d < 0)
						Rational(-n, -d)
					else
						Rational(n,d);
}

var2r(s : string, values : [Pair<string,string>])
{
	valueStr = fold(values,"",\valStr, val ->
		if (val.first == s) val.second else valStr);
	if ("" == valueStr)
		Rational(1,0)
	else
	{
		rational = s2r(valueStr); 
		getRational(rational.numerator,rational.denominator);
	}
}

vare2e(e : Expr, values : [Pair<string,string>]) -> Expr
{
	switch(e : Expr)
	{
		Div(e1,e2) : Div(vare2e(e1,values),vare2e(e2,values));
		Product(e1,e2) : Product(vare2e(e1,values),vare2e(e2,values));
		Sub(e1,e2) : Sub(vare2e(e1,values),vare2e(e2,values));
		Add(e1,e2) : Add(vare2e(e1,values),vare2e(e2,values));
		Neg(e1) : Neg(vare2e(e1,values));
		Var(s) : var2r(s,values);
		Rational(n,d) : Rational(n,d);
	}
}

s2r(str : string)
{
	neg = ref 1;
	onDigits = ref false;
	slashFound = ref false;
	invalid = ref false;
	finished = ref false;
	firstDigit = ref 0;
	num = ref 0;
	denom = ref 0;
	fori(0,strlen(str) - 1, \i ->
	{
		if (!^finished && !^invalid)
			if (^onDigits)
			{
				if (!isDigit(getCharAt(str,i)))
				{
					onDigits := false;
					if ("-" == getCharAt(str,i))
						invalid := true
					else
					{
						if (^slashFound)
						{
							denom := s2i(substring(str,^firstDigit,i - ^firstDigit));
							finished := true;
						}
						if ("/" == getCharAt(str,i))
						{
							if (^slashFound)
								invalid := true
							else
								slashFound := true;
						}
						else
							num := s2i(substring(str,^firstDigit,i - ^firstDigit));
					}
				}
			}
			else
			{
				if ("-" == getCharAt(str,i))
					neg := ^neg * -1
				else
					if (" " == getCharAt(str,i))
					{}
					else
						if (isDigit(getCharAt(str,i)))
						{
							onDigits := true;
							firstDigit := i;
						}
						else
							if ("/" == getCharAt(str,i) && !^slashFound)
								slashFound := true
							else
								invalid := true;
			}
	});
	if (^onDigits)
		if (^slashFound)
		{
			denom := s2i(substring(str,^firstDigit,strlen(str) - ^firstDigit));
			finished := true; 
		}
		else
			num := s2i(substring(str,^firstDigit,strlen(str) - ^firstDigit));
	if (^invalid)
		Rational(0,0)
	else
		if (^finished)
			Rational(^neg * ^num,^denom)
		else
			Rational(^neg * ^num,1);
}

r2s(rational : Rational)
{
	if (0 == rational.denominator)
		"INVALID"
	else
		if (1 == rational.denominator)
			i2s(rational.numerator)
		else
			i2s(rational.numerator) + "/" + i2s(rational.denominator);
}

main()
{
	test = "(x + y) /  Z * 16 - 16 * - f";
	result = parsic(algebraGrammar(), test, defaultPegActions);
	println(test + " = " +
		e2sVariables(result,[Pair("x","4 / 5"),Pair("f","- 16 / 7"),
		Pair("y","- 1   /   1"),Pair("Z","12")])
		+ " = " + r2s(calcVariables(result,[Pair("x","4 / 5"),Pair("f"," 16 / 7"),
		Pair("y","- 1   /   1"),Pair("Z","12")])));
}