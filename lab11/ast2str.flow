import MTC/lab11/NeMo_AST;

export
{
    ast2s(program : Program) -> string;
}

ast2s(program)
{
    declarations2s(program.decls) + "\n" + body2s(program.body,""); 
}

declarations2s(decls : [Declaration])
{
    if (0 == length(decls))
        ""
    else
    {
        currentDeclaration = decls[length(decls) - 1];
        declarations2s(removeIndex(decls,length(decls) - 1)) + 
            "VAR " + operand2s(currentDeclaration.var) + " : " 
            + type2s(currentDeclaration.type) + ";\n";
    }
}

type2s(type : Type)
{
    switch (type : Type)
    {
        IntType() : "INT";
        ArrayType(indexingType, valueType) : "[" +
            switch(indexingType : Type)
            {
                IntType() : "";
                ArrayType(subIndexingType,subValueType) : type2s(indexingType) + " ARRAY OF ";
            }
            + type2s(valueType) + "]";
    }
}

body2s(body,nesting)
{
    (if (body.structname != "Iteration") nesting else "") +
    switch(body : Body)
    {
        Assignment(var,expr) : operand2s(var) + " := " + expr2s(expr);
        Sequence(bodies) : "{\n"
            + fold(bodies,"",\acc,body1 -> acc + body2s(body1,nesting + "\t")
                + (if (body1.structname == "Sequence") "" else ";") + "\n")
            + nesting + "}";
        Choice(bodies) :
        {
            firstBody = bodies[0];
            "{\n"
            + fold(removeIndex(bodies,0),body2s(firstBody,nesting + "\t"),\acc,body1 -> acc + " U\n" + body2s(body1,nesting + "\t"))
            + "\n" + nesting + "}";
        }
        Iteration(sequence) : body2s(sequence,nesting) + "*";
        Test() : test2s(body,nesting);
        Function() : function2s(body);
    }
}

function2s(function)
{
    switch(function : Function)
    {
        Print(expr) : "print(" + expr2s(expr) + ")";
    }
}

test2s(test,nesting)
{
    switch (test : Test)
    {
        SimpleTest(relation) : "(" + relation2s(relation,0) + ") ?";
        While(relation,body) : "while (" + relation2s(relation,0) + ")\n" + body2s(body, nesting
                + (if (body.structname != "Sequence") "\t" else ""));
        If(relation,op_if,op_else) : "if (" + relation2s(relation,0) + ")\n" + body2s(op_if,nesting
                + (if (op_if.structname != "Sequence") "\t" else ""))
            + (if (1 == length(op_else)) "\n" + nesting + "else\n" + body2s(op_else[0],nesting
                    + (if (op_else[0].structname != "Sequence") "\t" else "")) else "");
    }
}

expr2s(expr)
{
    switch(expr : Expr)
    {
        Arithmetic() : arithmetic2s(expr,0);
        Functional() : functional2s(expr);
    }
}

// OPERATION PRIORITIES
// 1 for Add and Sub
// 2 for subtrahend, Product and Div
// 3 for divider and Neg
// 4 for Var and Rational

arithmetic2s(arithm, underOperationPriority)
{
	operationPriority = ref 0;
	result = switch (arithm : Arithmetic)
	{
		Div(a1,a2) :
		{
			operationPriority := 2;
			arithmetic2s(a1,2) + " / " + arithmetic2s(a2,3);
		}
		Product(a1,a2) :
		{
			operationPriority := 2;
			arithmetic2s(a1,2) + " * " + arithmetic2s(a2,2);
		}
		Add(a1,a2) :
		{
			operationPriority := 1;
            arithmetic2s(a1,1) + " + " + arithmetic2s(a2,1);
		}
		Sub(a1,a2) :
		{
			operationPriority := 1;
            arithmetic2s(a1,1) + " - " + arithmetic2s(a2,2);
		}
		Neg(a1) :
		{
			operationPriority := 3;
			"-" + arithmetic2s(a1,3);
		}
        Operand() :
        {
            operationPriority := 4;
            operand2s(arithm);
        }
	}
	if (^operationPriority < underOperationPriority)
		"(" + result + ")"
	else
		result;
}

functional2s(functional)
{
    switch(functional : Functional)
    {
        Apply(array,index) : "APP(" + expr2s(array) + ", " + expr2s(index) + ")";
        Update(array,index,new_value) : "UPD(" + expr2s(array) + ", " + expr2s(index)
            + ", " + expr2s(new_value) + ")";
    }
}

operand2s(operand)
{
    switch(operand : Operand)
    {
        Int(i) : i2s(i);
        Var(s) : s;
    }
}

// BINARY OPERATIONS PRIORITIES
// 1 for Or
// 2 for And
// 3 for Not

relation2s(relation,underOperationPriority)
{
    operationPriority = ref 0;
    result = switch(relation : Relation)
    {
        Or(r1,r2) :
        {   
            operationPriority := 1;
            relation2s(r1,1) + " || " + relation2s(r2,1);
        }
        And(r1,r2) :
        {
            operationPriority := 2;
            relation2s(r1,2) + " && " + relation2s(r2,2);
        }
        Not(r) :
        {
            operationPriority := 3;
            "~" + relation2s(r,3);
        }
        RelationAtom() : relationAtom2s(relation);
    }
    if (underOperationPriority > ^operationPriority)
        "(" + result + ")"
    else
        result;
}

relationAtom2s(relationAtom)
{
    switch(relationAtom : RelationAtom)
    {
        LesserEquals(a1,a2) : arithmetic2s(a1,0) + " <= " + arithmetic2s(a2,0);
        GreaterEquals(a1,a2) : arithmetic2s(a1,0) + " >= " + arithmetic2s(a2,0);
        Lesser(a1,a2) : arithmetic2s(a1,0) + " < " + arithmetic2s(a2,0);
        Greater(a1,a2) : arithmetic2s(a1,0) + " > " + arithmetic2s(a2,0);
        Equals(a1,a2) : arithmetic2s(a1,0) + " == " + arithmetic2s(a2,0);
    }
}